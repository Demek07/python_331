"""
Lesson 54
14.12.2023

Магические методы для арифметических операций

- Exception - исключение
- __add__(self, other) - сложение
- __sub__(self, other) - вычитание
- __mul__(self, other) - умножение
- __truediv__(self, other) - деление
- __floordiv__(self, other) - целочисленное деление
- __mod__(self, other) - остаток от деления
- __pow__(self, other) - возведение в степень

Операции "на месте" - inplace. Изменяют объект на месте. Например +=, -=, *=, /=, //=, %=, **=
- __iadd__(self, other) - сложение
- __isub__(self, other) - вычитание
- __imul__(self, other) - умножение
- __itruediv__(self, other) - деление
- __ifloordiv__(self, other) - целочисленное деление
- __imod__(self, other) - остаток от деления
- __ipow__(self, other) - возведение в степень


Обратные арифметические методы
- __radd__(self, other) - сложение
- __rsub__(self, other) - вычитание
- __rmul__(self, other) - умножение
- __rtruediv__(self, other) - деление
- __rfloordiv__(self, other) - целочисленное деление
- __rmod__(self, other) - остаток от деления
- __rpow__(self, other) - возведение в степень


__call__(self, *args, **kwargs) - вызывается когда объект вызывается как функция
Агрегация
Композиция
"""

"""
### 1. Функция-декоратор для функции
Это, пожалуй, самый распространенный вид декораторов. Он позволяет добавить дополнительную функциональность 
к существующим функциям без изменения их кода. Например, декораторы для логирования, измерения времени выполнения 
функции и так далее. В Django это используется для декорирования представлений, например, для проверки разрешений.

### 2. Функция-декоратор для метода класса
Похож на предыдущий тип, но применяется к методам классов. Он может использоваться для модификации поведения 
методов, например, для кэширования результатов или проверки прав доступа в методах класса.

### 3. Функция-декоратор для класса
Этот тип декораторов используется реже. Он позволяет модифицировать сам класс, например, добавлять ему новые 
методы или атрибуты, изменять его поведение. В Django они не очень распространены, но могут использоваться 
для создания различных миксинов или модификаторов классов.

### 4. Класс-декоратор для функции
Это более сложный и редко используемый вариант. Класс, действующий как декоратор, может предоставлять более 
гибкие возможности по сравнению с функцией-декоратором, такие как сохранение состояния. Однако из-за своей 
сложности он используется редко.

### 5. Класс-декоратор для метода класса
Этот тип декораторов используется ещё реже. Он может быть полезен в случаях, когда необходимо сохранять 
состояние или когда декоратор должен быть настраиваемым.

### 6. Класс-декоратор для класса
Это довольно редкий и сложный случай использования декораторов. Он может применяться для глобальных
 модификаций класса, но из-за сложности реализации и использования встречается нечасто.

### Частота использования и применение в Django
- **Наиболее часто используемые:** функциональные декораторы для функций и методов. В Django это 
видно на примере декораторов для представлений, например, `@login_required`.
- **Менее часто используемые:** классовые декораторы и функциональные декораторы для классов. Они 
могут использоваться в Django, но не так часто, как функциональные декораторы для функций и методов.
- **Редко используемые:** декораторы, реализованные с помощью классов для методов и классов, 
встречаются редко из-за своей сложности и специфичности.

### Возможности и ограничения
- **Возможно:** Создание декораторов всех вышеупомянутых типов. Особенно в рамках Django часто 
используются декораторы для управления доступом к представлениям и методам.
- **Ограничения:** Сложность и необходимость в глубоком

 понимании механизмов Python могут ограничивать использование некоторых типов декораторов, 
 особенно классовых декораторов для методов и классов.

**Классы-декораторы** являются особым случаем объектно-ориентированного программирования 
(ООП) в Python. Они позволяют нам изменять поведение функций или методов с помощью классов. 
Основная идея состоит в том, чтобы определить специальные методы в классе-декораторе, такие как 
`__call__`, которые модифицируют поведение функции или метода класса. Вот пример класса-декоратора:
"""


class DecoratorClass:
    def __init__(self, func: callable):
        self.func = func

    def __call__(self, message: str) -> str:
        # Добавим к сообщению префикс
        message = f'Prefix: {message}'
        # Вызовем функцию func
        result = self.func(message)
        return result


@DecoratorClass
def greeter(message: str) -> str:
    return f'Hello, {message}!'


print(greeter('World'))


# Функция декорирующая класс. Добавляет к классу атрибут is_used

def class_decorator(cls):
    class Wrapped(cls):
        def hello(self):
            print("Привет от класса с декоратором!")

    return Wrapped


@class_decorator
class MyClass:
    def hello(self):
        print("Привет от исходного класса!")

    def bye(self):
        print("Пока от исходного класса!")


my_obj = MyClass()
my_obj.hello()
my_obj.bye()
