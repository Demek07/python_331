"""
Lesson 25
28.11.2023
Знакомство с ООП в Python
Правила нейминга
Всё в Python - объекты, сравнили свой класс со строкой
Методы и атрибуты класса
Познакомились с __init__ и __new__
Посмотрели как создается экземпляр класса (сначала __new__, потом __init__)
Посмотрели что self позволяет работать с атрибутами и методами экземпляра класса
@staticmethod - декоратор для методов которые не работают с атрибутами класса и экземпляра класса
@classmethod - декоратор для методов которые работают с атрибутами класса
cls - аналог self, но для класса
"""


class Car:
    """
    Класс для представления автомобиля.
    """
    id = 0 # Атрибут класса

    def __init__(self, model: str) -> None:
        self.model = model
        self.id = Car.id
        Car.id += 1
        print(f'Создан автомобиль {self.model} с id {self.id}')

    def run(self) -> None:
        """
        Метод для запуска автомобиля.
        По сути, это функция, описанная внутри класса.
        """
        print(f'Автомобиль {self.model} заведен')

    @staticmethod
    def beep() -> None:
        """
        Статический метод для издания звукового сигнала.
        Он не использует атрибуты экземпляра и атрибуты класса.
        Т.е. это функция которая связана с классом, но не использует его атрибуты.
        А без @staticmethod и без self - Она не будет работать.
        """
        print('Би-бип!')

    @classmethod
    def get_car_count(cls) -> int:
        """
        Метод, который возвращает количество созданных автомобилей.
        Является методом класса, т.к. использует атрибут класса, и без
        декоратора @classmethod не будет работать.
        """
        return cls.id

    def get_car_id(self) -> int:
        """
        Метод, который возвращает id автомобиля.
        """
        return self.id


# Создаем экземпляры класса Car
car1 = Car('BMW')
car2 = Car('Audi')
car3 = Car('Mercedes')

# Проверяем счетчик созданных автомобилей

# Мы можем обратиться напрямую к атрибуту класса через имя класса
print(f'Car.id = {Car.id}')
# Мы можем воспользоваться методом класса, обратившись к классу (при условии @classmethod)
print(Car.get_car_count())
# Мы можем воспользоваться методом класса, обратившись к экземпляру класса (при условии @classmethod)
print(car1.get_car_count())


# Проверяем id автомобилей (у каждого будет свой уникальный id)
print(car1.get_car_id())
print(car2.get_car_id())
print(car3.get_car_id())
